{"version":3,"file":"tooltip.js","sources":["../../src/tooltip/tooltip.jsx"],"sourcesContent":["/*\n * Copyright 2017-2022 Elyra Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n\tThis code is a modified version from portal-common-api for the Elyra canvas tooltips\n*/\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { Portal } from \"react-portal\";\nimport { Link } from \"carbon-components-react\";\n\nclass ToolTip extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tisTooltipVisible: false\n\t\t};\n\n\t\tthis.pendingTooltip = null;\n\t\tthis.hideTooltipOnScrollAndResize = this.hideTooltipOnScrollAndResize.bind(this);\n\t}\n\n\tcomponentDidMount() {\n\t\twindow.addEventListener(\"scroll\", this.hideTooltipOnScrollAndResize, true);\n\t\twindow.addEventListener(\"resize\", this.hideTooltipOnScrollAndResize, true);\n\t\tif (this.props.targetObj) {\n\t\t\tthis.setTooltipVisible(true);\n\t\t}\n\t}\n\n\tcomponentWillUnmount() {\n\t\twindow.removeEventListener(\"scroll\", this.hideTooltipOnScrollAndResize, true);\n\t\twindow.removeEventListener(\"resize\", this.hideTooltipOnScrollAndResize, true);\n\t\tif (this.pendingTooltip) {\n\t\t\tclearTimeout(this.pendingTooltip);\n\t\t}\n\t}\n\n\tsetTooltipVisible(visible) {\n\t\t// clear the display timer if set\n\t\tif (!this.showTooltip() || (!visible && this.pendingTooltip)) {\n\t\t\tclearTimeout(this.pendingTooltip);\n\t\t\tthis.pendingTooltip = null;\n\t\t\tthis.setState({\n\t\t\t\tisTooltipVisible: false\n\t\t\t});\n\t\t}\n\n\n\t\tif (this.showTooltip()) {\n\t\t\tconst tooltip = document.querySelector(\"[data-id='\" + this.props.id + \"']\");\n\t\t\tthis.pendingTooltip = null;\n\t\t\tthis.setState({\n\t\t\t\tisTooltipVisible: visible\n\t\t\t});\n\t\t\t// updates the tooltip display\n\t\t\tif (visible) {\n\t\t\t\tlet tooltipTrigger = null;\n\t\t\t\tif (this.props.targetObj) {\n\t\t\t\t\ttooltipTrigger = this.props.targetObj;\n\t\t\t\t} else {\n\t\t\t\t\ttooltipTrigger = document.querySelector(\"[data-id='\" + this.props.id + \"-trigger']\");\n\t\t\t\t}\n\t\t\t\tif (tooltipTrigger && tooltip) {\n\t\t\t\t\tthis.updateTooltipLayout(tooltip, tooltipTrigger, tooltip.getAttribute(\"direction\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetStyleValue(value) {\n\t\treturn value + \"px\";\n\t}\n\n\tgetNewDirection(currentDirection) {\n\t\tlet newDirection;\n\t\tswitch (currentDirection) {\n\t\tcase \"top\":\n\t\t\tnewDirection = \"bottom\";\n\t\t\tbreak;\n\t\tcase \"bottom\":\n\t\t\tnewDirection = \"top\";\n\t\t\tbreak;\n\t\tcase \"left\":\n\t\t\tnewDirection = \"right\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnewDirection = \"left\";\n\t\t}\n\t\treturn newDirection;\n\t}\n\n\tshowTooltip() {\n\t\tconst canDisplayFullText = this.canDisplayFullText(this.triggerRef);\n\t\tconst showToolTip = (\n\t\t\t// show tooltip if not disabled and showToolTipIfTruncated is false\n\t\t\t(!this.props.disable && !this.props.showToolTipIfTruncated) ||\n\t\t\t// show tooltip if not disabled and showToolTipIfTruncated is true and string is truncated\n\t\t\t(!this.props.disable && this.props.showToolTipIfTruncated && !canDisplayFullText));\n\t\treturn showToolTip;\n\t}\n\n\t// Return true if the string can be displayed in the available space\n\t// Return false if the string is truncated and ellipsis is shown on the UI\n\t// (offsetWidth) is a measurement in pixels of the element's CSS width, including any borders, padding, and vertical scrollbars\n\t// (scrollWidth) value is equal to the minimum width the element would require\n\t//  in order to fit all the content in the viewport without using a horizontal scrollbar\n\tcanDisplayFullText(elem) {\n\t\tif (elem) {\n\t\t\tconst firstChildWidth = elem.firstChild && elem.firstChild.scrollWidth ? elem.firstChild.scrollWidth : 0;\n\t\t\tconst displayWidth = elem.offsetWidth;\n\t\t\tlet fullWidth = firstChildWidth;\n\t\t\tif (firstChildWidth === 0) {\n\t\t\t\tfullWidth = elem.scrollWidth;\n\t\t\t}\n\t\t\tconst canDisplayFullText = fullWidth <= displayWidth;\n\t\t\treturn canDisplayFullText;\n\t\t}\n\t\treturn false; // Show tooltip if we cannot read the width (Canvas objects)\n\t}\n\n\tshowTooltipWithDelay() {\n\n\t\t// set a delay on displaying the tooltip\n\t\tif (!this.pendingTooltip && this.showTooltip()) {\n\t\t\tconst that = this;\n\t\t\tthis.pendingTooltip = setTimeout(function() {\n\t\t\t\tthat.setTooltipVisible(true);\n\t\t\t}, this.props.delay);\n\t\t}\n\n\t}\n\n\tupdateTooltipLayout(tooltip, tooltipTrigger, direction) {\n\t\tconst tooltipDirection = direction;\n\t\tconst viewPortWidth = document.documentElement.clientWidth;\n\t\tconst viewPortHeight = document.documentElement.clientHeight;\n\t\tconst triggerLayout = tooltipTrigger.getBoundingClientRect();\n\t\tconst pointer = tooltip.querySelector(\"svg\");\n\t\tconst pointerLayout = pointer.getBoundingClientRect();\n\t\tconst pointerCorrection = 1;\n\n\t\t// always initialize tooltip location so it's all visible to ensure adjustments are done on the right size\n\t\ttooltip.style.left = this.getStyleValue(triggerLayout.left);\n\t\ttooltip.style.top = this.getStyleValue(triggerLayout.top);\n\n\t\tif (this.props.mousePos) {\n\t\t\tthis.updateLocationBasedOnMousePos(tooltip, this.props.mousePos, direction);\n\t\t} else { // tooltip relativ to element\n\t\t\t// tooltip - left correction\n\t\t\tif (tooltipDirection === \"top\" || tooltipDirection === \"bottom\") {\n\t\t\t\tlet tooltipLeft = triggerLayout.left;\n\t\t\t\tif (tooltip.offsetWidth > triggerLayout.width) {\n\t\t\t\t\ttooltipLeft -= (tooltip.offsetWidth - triggerLayout.width) / 2; // distribute overlap evenly left and right\n\t\t\t\t\tif (tooltipLeft < 0) {\n\t\t\t\t\t\ttooltipLeft = 2; // hitting left border\n\t\t\t\t\t}\n\t\t\t\t} else if (tooltip.offsetWidth < triggerLayout.width) {\n\t\t\t\t\ttooltipLeft += (triggerLayout.width - tooltip.offsetWidth) / 2; // center tip within triggerLayout\n\t\t\t\t}\n\t\t\t\ttooltip.style.left = this.getStyleValue(tooltipLeft);\n\t\t\t\tif ((tooltipLeft + tooltip.offsetWidth) > viewPortWidth) {\n\t\t\t\t\ttooltip.style.left = this.getStyleValue(viewPortWidth - tooltip.offsetWidth); // hitting right border\n\t\t\t\t}\n\t\t\t} else if (tooltipDirection === \"left\") {\n\t\t\t\t// For long tooltips, tooltip.offsetWidth is updated after setting tooltip.style.left. Ensure tooltip doesn't overlap tooltipTrigger element.\n\t\t\t\twhile ((tooltip.offsetLeft + tooltip.offsetWidth + pointerLayout.width) > Math.round(triggerLayout.left)) {\n\t\t\t\t\ttooltip.style.left = this.getStyleValue(triggerLayout.left - tooltip.offsetWidth - pointerLayout.width);\n\t\t\t\t}\n\t\t\t} else if (tooltipDirection === \"right\") {\n\t\t\t\ttooltip.style.left = this.getStyleValue(triggerLayout.right + pointerLayout.width);\n\t\t\t}\n\n\t\t\t// tooltip - top correction\n\t\t\tif (tooltipDirection === \"top\") {\n\t\t\t\ttooltip.style.top = this.getStyleValue(triggerLayout.top - pointerLayout.height - tooltip.offsetHeight);\n\t\t\t} else if (tooltipDirection === \"bottom\") {\n\t\t\t\ttooltip.style.top = this.getStyleValue(triggerLayout.bottom + pointerLayout.height);\n\t\t\t} else if (tooltipDirection === \"left\" || tooltipDirection === \"right\") {\n\t\t\t\tlet tooltipTop = triggerLayout.top;\n\t\t\t\tif (tooltip.offsetHeight > triggerLayout.height) {\n\t\t\t\t\ttooltipTop -= (tooltip.offsetHeight - triggerLayout.height) / 2; // distribute overlap evenly top and bottom\n\t\t\t\t\tif (tooltipTop < 0) {\n\t\t\t\t\t\ttooltipTop = triggerLayout.top; // hitting top border\n\t\t\t\t\t}\n\t\t\t\t} else if (tooltip.offsetHeight < triggerLayout.height) {\n\t\t\t\t\ttooltipTop += (triggerLayout.height - tooltip.offsetHeight) / 2; // center tip within triggerLayout\n\t\t\t\t}\n\t\t\t\ttooltip.style.top = this.getStyleValue(tooltipTop + pointerCorrection);\n\t\t\t\tif ((viewPortHeight - tooltip.offsetHeight) < triggerLayout.top) {\n\t\t\t\t\ttooltip.style.top = this.getStyleValue(viewPortHeight - tooltip.offsetHeight); // hitting bottom border\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// pointer - left correction\n\t\t\tif (tooltipDirection === \"top\" || tooltipDirection === \"bottom\") {\n\t\t\t\tpointer.style.left = this.getStyleValue(triggerLayout.left - tooltip.getBoundingClientRect().left +\n\t\t\t\t\ttooltipTrigger.getBoundingClientRect().width / 2 - pointerLayout.width / 2\t + pointerCorrection);\n\t\t\t} else if (tooltipDirection === \"left\") {\n\t\t\t\tpointer.style.left = this.getStyleValue(tooltip.offsetWidth - 3);\n\t\t\t} else if (tooltipDirection === \"right\") {\n\t\t\t\tpointer.style.left = this.getStyleValue(-pointerLayout.width + 2);\n\t\t\t}\n\n\t\t\t// pointer - top correction\n\t\t\tif (tooltipDirection === \"top\") {\n\t\t\t\tpointer.style.top = this.getStyleValue(tooltip.offsetHeight - 5);\n\t\t\t} else if (tooltipDirection === \"bottom\") {\n\t\t\t\tpointer.style.top = \"-11px\";\n\t\t\t} else if (tooltipDirection === \"left\" || tooltipDirection === \"right\") {\n\t\t\t\tpointer.style.top = this.getStyleValue(triggerLayout.top - tooltip.getBoundingClientRect().top +\n\t\t\t\t\ttooltipTrigger.offsetHeight / 2 - pointerLayout.height / 2);\n\t\t\t}\n\t\t}\n\n\t\t// check if out-of-bounds at the end and if so, trigger new layout on opposite site if not already re-rendered already\n\t\tif (this.isOutOfBounds(tooltip) && tooltip.getAttribute(\"direction\") === tooltipDirection) {\n\t\t\tconst newDirection = this.getNewDirection(tooltipDirection);\n\t\t\tthis.updateTooltipLayout(tooltip, tooltipTrigger, newDirection);\n\t\t\t// update class name directly, otherwise setState triggers re-render loop in canvas\n\t\t\t// also call after updateTooltipLayout, otherwise the newDirection and class of trigger are the same\n\t\t\ttooltip.setAttribute(\"direction\", newDirection);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tupdateLocationBasedOnMousePos(tooltip, mousePos, direction) {\n\t\tconst tooltipDirection = direction;\n\t\tconst viewPortWidth = document.documentElement.clientWidth;\n\t\tconst viewPortHeight = document.documentElement.clientHeight;\n\t\tconst pointer = tooltip.querySelector(\"svg\");\n\t\tconst pointerLayout = pointer.getBoundingClientRect();\n\t\tconst pointerCorrection = 1;\n\n\t\tconst mouseX = this.props.mousePos.x;\n\t\tconst mouseY = this.props.mousePos.y;\n\t\t// if mouse position is passed in, use the cursor as reference point\n\n\t\t// tooltip - left correction\n\t\tif (tooltipDirection === \"top\" || tooltipDirection === \"bottom\") {\n\t\t\tlet tooltipLeft = mouseX - tooltip.offsetWidth / 2;\n\t\t\tif ((viewPortWidth - tooltip.offsetWidth) < tooltipLeft) {\n\t\t\t\ttooltipLeft = viewPortWidth - tooltip.offsetWidth; // hitting right border\n\t\t\t} else if (tooltipLeft < 0) {\n\t\t\t\ttooltipLeft = 2; // hitting left border\n\t\t\t}\n\t\t\ttooltip.style.left = this.getStyleValue(tooltipLeft);\n\t\t} else if (tooltipDirection === \"left\") {\n\t\t\ttooltip.style.left = this.getStyleValue(mouseX - tooltip.offsetWidth - pointerLayout.width - 5);\n\t\t} else if (tooltipDirection === \"right\") {\n\t\t\ttooltip.style.left = this.getStyleValue(mouseX + pointerLayout.width + 5);\n\t\t}\n\n\t\t// tooltip - top correction\n\t\tif (tooltipDirection === \"top\") {\n\t\t\ttooltip.style.top = this.getStyleValue(mouseY - pointerLayout.height - tooltip.offsetHeight);\n\t\t} else if (tooltipDirection === \"bottom\") {\n\t\t\ttooltip.style.top = this.getStyleValue(mouseY + 2 * pointerLayout.height);\n\t\t} else if (tooltipDirection === \"left\" || tooltipDirection === \"right\") {\n\t\t\tlet tooltipTop = mouseY - tooltip.offsetHeight / 2;\n\t\t\tif ((viewPortHeight - tooltip.offsetHeight) < tooltipTop) {\n\t\t\t\ttooltipTop = viewPortHeight - tooltip.offsetHeight; // hitting bottom border\n\t\t\t} else if (tooltipTop < 0) {\n\t\t\t\ttooltipTop = 2; // hitting top border\n\t\t\t}\n\t\t\ttooltip.style.top = this.getStyleValue(tooltipTop + pointerCorrection);\n\t\t}\n\n\t\t// pointer - left correction\n\t\tif (tooltipDirection === \"top\" || tooltipDirection === \"bottom\") {\n\t\t\tpointer.style.left = this.getStyleValue(mouseX - tooltip.getBoundingClientRect().left - pointerLayout.width / 2);\n\t\t} else if (tooltipDirection === \"left\") {\n\t\t\tpointer.style.left = this.getStyleValue(tooltip.offsetWidth - 3);\n\t\t} else if (tooltipDirection === \"right\") {\n\t\t\tpointer.style.left = this.getStyleValue(-pointerLayout.width + 2);\n\t\t}\n\n\t\t// pointer - top correction\n\t\tif (tooltipDirection === \"top\") {\n\t\t\tpointer.style.top = this.getStyleValue(tooltip.offsetHeight - 5);\n\t\t} else if (tooltipDirection === \"bottom\") {\n\t\t\tpointer.style.top = \"-11px\";\n\t\t} else if (tooltipDirection === \"left\" || tooltipDirection === \"right\") {\n\t\t\tpointer.style.top = this.getStyleValue(mouseY - tooltip.getBoundingClientRect().top - pointerLayout.height / 2);\n\t\t}\n\t}\n\n\tisOutOfBounds(tooltip) {\n\t\tconst tooltipLeft = parseFloat(tooltip.style.left);\n\t\tconst tooltipTop = parseFloat(tooltip.style.top);\n\t\treturn (((tooltipLeft + tooltip.offsetWidth) > document.documentElement.clientWidth) || // to the right\n\t\t\t\t(tooltipLeft < 0) || // to the left\n\t\t\t\t(tooltipTop < 0) || // to the top\n\t\t\t\t((tooltipTop + tooltip.offsetHeight) > document.documentElement.clientHeight)); // to the bottom\n\t}\n\n\ttoggleTooltipOnClick(evt) {\n\t\t// 'blur' event occurs before 'click' event. Because of this, onBlur function is called which hides the tooltip.\n\t\t// To prevent this default behavior, stopPropagation and preventDefault is used.\n\t\tevt.stopPropagation();\n\t\tevt.preventDefault();\n\t\tif (this.state.isTooltipVisible) {\n\t\t\t// Tooltip is visible and user clicks on trigger element again, hide tooltip\n\t\t\tthis.setTooltipVisible(false);\n\t\t} else {\n\t\t\tthis.setTooltipVisible(true);\n\t\t}\n\t}\n\n\thideTooltipOnScrollAndResize(evt) {\n\t\tif (this.state.isTooltipVisible) {\n\t\t\tthis.setTooltipVisible(false);\n\t\t}\n\t}\n\n\ttooltipLinkOnClick(url) {\n\t\twindow.open(url, \"_blank\", \"noopener\");\n\t}\n\n\trender() {\n\t\tlet tooltipContent = null;\n\t\tlet triggerContent = null;\n\t\tif (this.props.children) {\n\t\t\t// when children are passed in, tooltip will handle show/hide, otherwise consumer has to hide show/hide tooltip\n\t\t\tconst mouseover = () => this.setTooltipVisible(true);\n\t\t\tconst mouseleave = () => this.setTooltipVisible(false);\n\t\t\tconst mousedown = () => this.setTooltipVisible(false);\n\t\t\t// `focus` event occurs before `click`. Adding timeout in onFocus function to ensure click is executed first.\n\t\t\t// Ref - https://stackoverflow.com/a/49512400\n\t\t\tconst onFocus = () => this.showTooltipWithDelay();\n\t\t\tconst onBlur = (evt) => {\n\t\t\t\t// Keep tooltip visible when clicked on a link.\n\t\t\t\t// Since link is an anchor tag without \"href\" attribute, it has relatedTarget=null\n\t\t\t\tif (evt.relatedTarget !== null) {\n\t\t\t\t\tthis.setTooltipVisible(false);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst click = (evt) => this.toggleTooltipOnClick(evt);\n\n\t\t\ttriggerContent = (<div\n\t\t\t\tdata-id={this.props.id + \"-trigger\"}\n\t\t\t\tclassName=\"tooltip-trigger\"\n\t\t\t\tonMouseOver={!this.props.showToolTipOnClick ? mouseover : null}\n\t\t\t\tonMouseLeave={!this.props.showToolTipOnClick ? mouseleave : null}\n\t\t\t\tonMouseDown={!this.props.showToolTipOnClick ? mousedown : null}\n\t\t\t\tonClick={this.props.showToolTipOnClick ? click : null}\n\t\t\t\tonFocus={this.props.showToolTipOnClick ? onFocus : null} // When focused using keyboard\n\t\t\t\tonBlur={this.props.showToolTipOnClick ? onBlur : null}\n\t\t\t\ttabIndex={this.props.showToolTipOnClick ? 0 : null}\n\t\t\t\tref={(ref) => (this.triggerRef = ref)}\n\t\t\t>\n\t\t\t\t{this.props.children}\n\t\t\t</div>);\n\t\t}\n\n\t\tif ((typeof this.props.tip) === \"string\") {\n\t\t\ttooltipContent = (\n\t\t\t\t<span id=\"tooltipContainer\">\n\t\t\t\t\t{this.props.tip}\n\t\t\t\t</span>\n\t\t\t);\n\t\t} else if ((typeof this.props.tip) === \"object\") {\n\t\t\ttooltipContent = (\n\t\t\t\t<div id=\"tooltipContainer\">\n\t\t\t\t\t{this.props.tip}\n\t\t\t\t</div>\n\t\t\t);\n\t\t} else if ((typeof this.props.tip) === \"function\") {\n\t\t\ttooltipContent = this.props.tip();\n\t\t}\n\n\t\tlet tipClass = \"common-canvas-tooltip\";\n\t\tif (this.props.className) {\n\t\t\ttipClass += \" \" + this.props.className;\n\t\t}\n\n\t\tlet link = null;\n\t\tif (this.state.isTooltipVisible && this.props.tooltipLinkHandler && this.props.link) {\n\t\t\tconst linkInformation = this.props.tooltipLinkHandler(this.props.link);\n\t\t\t// Verify tooltipLinkHandler returns object in correct format\n\t\t\tif (typeof linkInformation === \"object\" && linkInformation.label && linkInformation.url) {\n\t\t\t\tlink = (<Link\n\t\t\t\t\tclassName=\"tooltip-link\"\n\t\t\t\t\tid={this.props.link.id}\n\t\t\t\t\tonClick={this.tooltipLinkOnClick.bind(this, linkInformation.url)}\n\t\t\t\t>\n\t\t\t\t\t{linkInformation.label}\n\t\t\t\t</Link>);\n\t\t\t}\n\t\t}\n\n\t\tlet tooltip = null;\n\t\tif (tooltipContent || link) {\n\t\t\ttooltip = (\n\t\t\t\t<Portal>\n\t\t\t\t\t<div data-id={this.props.id} className={tipClass} aria-hidden={!this.state.isTooltipVisible} direction={this.props.direction}>\n\t\t\t\t\t\t<svg id=\"tipArrow\" x=\"0px\" y=\"0px\" viewBox=\"0 0 9.1 16.1\">\n\t\t\t\t\t\t\t<polyline points=\"9.1,15.7 1.4,8.1 9.1,0.5\" />\n\t\t\t\t\t\t\t<polygon points=\"8.1,16.1 0,8.1 8.1,0 8.1,1.4 1.4,8.1 8.1,14.7\" />\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t{tooltipContent}\n\t\t\t\t\t\t{link}\n\t\t\t\t\t</div>\n\t\t\t\t</Portal>\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\t<div className=\"tooltip-container\">\n\t\t\t\t{triggerContent}\n\t\t\t\t{tooltip}\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nToolTip.propTypes = {\n\ttip: PropTypes.oneOfType([PropTypes.string, PropTypes.element, PropTypes.func]).isRequired,\n\tlink: PropTypes.object,\n\ttooltipLinkHandler: PropTypes.func,\n\tdirection: PropTypes.oneOf([\"left\", \"right\", \"top\", \"bottom\"]),\n\tchildren: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\ttargetObj: PropTypes.object,\n\tid: PropTypes.string.isRequired,\n\tclassName: PropTypes.string,\n\tmousePos: PropTypes.object,\n\tdisable: PropTypes.bool, // Tooltip will not show if disabled\n\tshowToolTipIfTruncated: PropTypes.bool, // Set to true to only display tooltip if full text does not fit in displayable width\n\tdelay: PropTypes.number,\n\tshowToolTipOnClick: PropTypes.bool\n};\n\nToolTip.defaultProps = {\n\tdelay: 200,\n\tdirection: \"bottom\",\n\tshowToolTipIfTruncated: false, // False will always show Tooltip even when whole word can be displayed\n\tshowToolTipOnClick: false\n};\n\nexport default ToolTip;\n"],"names":["ToolTip","_React$Component","_inherits","_super","_createSuper","props","_this","_classCallCheck","call","state","isTooltipVisible","pendingTooltip","hideTooltipOnScrollAndResize","bind","_assertThisInitialized","_createClass","key","value","window","addEventListener","this","targetObj","setTooltipVisible","removeEventListener","clearTimeout","visible","showTooltip","setState","tooltip","document","querySelector","id","tooltipTrigger","updateTooltipLayout","getAttribute","currentDirection","newDirection","canDisplayFullText","triggerRef","disable","showToolTipIfTruncated","elem","firstChildWidth","firstChild","scrollWidth","displayWidth","offsetWidth","fullWidth","that","setTimeout","delay","direction","tooltipDirection","viewPortWidth","documentElement","clientWidth","viewPortHeight","clientHeight","triggerLayout","getBoundingClientRect","pointer","pointerLayout","style","left","getStyleValue","top","mousePos","updateLocationBasedOnMousePos","tooltipLeft","width","offsetLeft","Math","round","right","height","offsetHeight","bottom","tooltipTop","isOutOfBounds","getNewDirection","setAttribute","mouseX","x","mouseY","y","parseFloat","evt","stopPropagation","preventDefault","url","open","_this2","tooltipContent","triggerContent","children","React","createElement","className","onMouseOver","showToolTipOnClick","onMouseLeave","onMouseDown","onClick","toggleTooltipOnClick","onFocus","showTooltipWithDelay","onBlur","relatedTarget","tabIndex","ref","tip","_typeof","tipClass","link","tooltipLinkHandler","linkInformation","label","Link","tooltipLinkOnClick","Portal","viewBox","points","Component","defaultProps"],"mappings":"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"}